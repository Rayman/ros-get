#!/usr/bin/env python
from __future__ import print_function

import errno
import logging
import os
from argparse import ArgumentParser, Namespace

from rosdistro import get_cached_distribution, get_index, get_index_url
from rosdistro.dependency_walker import SourceDependencyWalker
from rosinstall_generator.generator import generate_rosinstall_for_repos
from vcstool.commands.import_ import get_repos_in_rosinstall_format, generate_jobs
from vcstool.executor import execute_jobs, output_repositories, output_results

logging.basicConfig()
logging.getLogger().setLevel(logging.DEBUG)
logger = logging.getLogger(__name__)


def mkdir_p(path):
    try:
        os.makedirs(path)
    except OSError as exc:  # Python >2.5
        if exc.errno == errno.EEXIST and os.path.isdir(path):
            pass
        else:
            raise


def add_pkgs_to_installed_list(pkgs):
    workspace = os.getenv('TUE_WORKSPACE', None)
    installed_dir = os.path.join(workspace, '.env', 'installed')

    mkdir_p(installed_dir)

    # touch the file
    for pkg in pkgs:
        logger.debug('marking for installation: %s', pkg)
        open(os.path.join(installed_dir, pkg), 'a').close()


def install_dependencies(path):
    # TODO:
    raise NotImplementedError()


def install(pkgs):
    # TODO: get distro from environment
    distroname = 'tuekinetic'
    workspace = os.getenv('TUE_WORKSPACE', None)
    target_path = os.path.join(workspace, 'src')

    # TODO: check if the packages extist

    add_pkgs_to_installed_list(pkgs)

    # let's figure out the dependent packages

    index = get_index(get_index_url())
    distro = get_cached_distribution(index, distroname)

    walker = SourceDependencyWalker(distro)
    packages = set()

    for package in pkgs:
        packages |= walker.get_recursive_depends(package, ['buildtool', 'build', 'run', 'test'],
                                                 ros_packages_only=True, ignore_pkgs=packages)
        packages.add(package)

    print('The following packages will be installed:')
    for package in packages:
        print(' ', package)

    # now let's figure out which repos these dependencies belong
    repos = {}
    for package in packages:
        repository_name = distro.source_packages[package].repository_name
        repository = distro.repositories[repository_name]

        # TODO: check duplicates
        repos[repository_name] = repository

    # generate a rosinstall file
    config = generate_rosinstall_for_repos(repos, version_tag=False, tar=False)

    # convert it to the vcs format
    config = get_repos_in_rosinstall_format(config)

    jobs = generate_jobs(config, Namespace(path=target_path))
    print('updating the following repositories:')
    output_repositories([job['client'] for job in jobs])

    results = execute_jobs(jobs, show_progress=True, number_of_workers=10)
    output_results(results)

    # install dependencies
    install_dependencies(target_path)


def not_implemented(args):
    raise NotImplementedError()


if __name__ == '__main__':
    parser = ArgumentParser()
    subparsers = parser.add_subparsers()

    subparser = subparsers.add_parser('install', help='install packages')
    subparser.set_defaults(func=install)
    subparser.add_argument('pkgs', nargs='+', metavar='pkg')

    subparser = subparsers.add_parser('update', help='update list of available packages')
    subparser.set_defaults(func=not_implemented)

    subparser = subparsers.add_parser('upgrade', help='upgrade the workspace by installing/upgrading packages')
    subparser.set_defaults(func=not_implemented)

    subparser = subparsers.add_parser('remove', help='remove packages')
    subparser.set_defaults(func=not_implemented)

    subparser = subparsers.add_parser('autoremove', help='remove automatically all unused packages')
    subparser.set_defaults(func=not_implemented)

    args = parser.parse_args()
    func = args.func
    del args.func
    exit(func(**vars(args)))
